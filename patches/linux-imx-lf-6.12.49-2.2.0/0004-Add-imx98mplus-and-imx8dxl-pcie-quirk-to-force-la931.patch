From bde838222d49341e24e99e4218fe0af9f76ef5fa Mon Sep 17 00:00:00 2001
From: Francois Massot-Pellet <francois.massot-pellet@nxp.com>
Date: Fri, 23 Jan 2026 15:48:05 +0100
Subject: [PATCH] Add imx8 pcie quirk to force 64MB la9310 BAR0 and fit hw
 capability.

Signed-off-by: Francois Massot-Pellet <francois.massot-pellet@nxp.com>
---
 drivers/pci/probe.c  | 20 ++++++++++
 drivers/pci/quirks.c | 92 ++++++++++++++++++++++++++++++++++++++++++++
 2 files changed, 112 insertions(+)

diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index b358b93a0275..5ba2dee97735 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -23,6 +23,8 @@
 
 #define CARDBUS_LATENCY_TIMER	176	/* secondary latency timer */
 #define CARDBUS_RESERVE_BUSNR	3
+#define IMX_LA9310_BAR_RSIZE_MASK 0xfc000000 /* For 64MB */
+#define IMX_LA9310_BAR_OFFSET 0x10
 
 static struct resource busn_resource = {
 	.name	= "PCI busn",
@@ -209,6 +211,24 @@ int __pci_read_base(struct pci_dev *dev, enum pci_bar_type type,
 	if (PCI_POSSIBLE_ERROR(sz))
 		sz = 0;
 
+	/*
+	 * LA9310 device BAR0 default size 256MB is too large for imx8mp/8dxl
+	 * as workaround we map only first 64MB and we will update EP BAR0_MASK
+	 * at runtime before accessing BAR1-5 and avoid Bus Errors
+	 */
+	if (of_machine_is_compatible("fsl,imx8mp") ||
+			of_machine_is_compatible("fsl,imx8dxl") ||
+			of_machine_is_compatible("fsl,imx8mm")) {
+		if ((sz < IMX_LA9310_BAR_RSIZE_MASK) &&
+			((dev->device == PCI_DEVICE_ID_LA9310) ||
+			(dev->device == PCI_DEVICE_ID_LA9310_DISABLE_CIP)) &&
+			(pos == IMX_LA9310_BAR_OFFSET)) {
+				pci_info(dev, "reg 0x%x: forcing BAR0 readback 0x%08x to 0xfc000000 (i.e.64MB)\n",
+					pos,sz);
+				sz = IMX_LA9310_BAR_RSIZE_MASK;
+		}
+	}
+
 	/*
 	 * I don't know how l can have all bits set.  Copied from old code.
 	 * Maybe it fixes a bug on some ancient platform.
diff --git a/drivers/pci/quirks.c b/drivers/pci/quirks.c
index 9c97c740c4b8..2c024d5c7913 100644
--- a/drivers/pci/quirks.c
+++ b/drivers/pci/quirks.c
@@ -31,6 +31,7 @@
 #include <linux/pm_runtime.h>
 #include <linux/suspend.h>
 #include <linux/switchtec.h>
+#include <linux/of.h>
 #include "pci.h"
 
 /*
@@ -3759,6 +3760,97 @@ DECLARE_PCI_FIXUP_EARLY(PCI_VENDOR_ID_FREESCALE, PCI_DEVICE_ID_LA9310_DISABLE_CI
 DECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_MELLANOX, PCI_ANY_ID,
                        mellanox_check_broken_intx_masking);
 
+#define ENABLE_INBOUND_MEM_ACCESS       0x02
+#define SET_BAR_MASK_VAL                0x3ffffff /*  64MB */
+#define SET_BAR_MASK_MP                 0x18000000
+#define PCIE_RHOM_DBI_BASE              0x3400000
+#define PCIE_CMD_REG_OFFSET             0x4
+#define PCIE_BAR_MASK_REG_0             0x1010
+#define PCIE_BAR_MASK_REG_1             0x10
+#define PCIE_HCTRL_PHY                  0x33B00000
+#define PCIE_HCTRL_OFFSET               0x214
+#define PICE_HCTRL_TRGT_IVAL            0x10000000
+#define PICE_HCTRL_TRGT_FVAL            0x18000000
+#define BOARD_TYPE_DXL                  1
+#define BOARD_TYPE_MP                   2
+#define BOARD_TYPE_IMX95                3
+
+static void quirk_la9310_config_mem(struct pci_dev *pdev)
+{
+       u32 size = 0;
+       u8 __iomem *vaddr = NULL,
+          *vaddr_hctrl = NULL;
+       phys_addr_t phys_addr = 0;
+       int8_t board_type = 0;
+
+       if ((of_machine_is_compatible("fsl,imx8mp") ||
+               of_machine_is_compatible("fsl,imx8mm"))) {
+               board_type = BOARD_TYPE_MP;
+       } else if ((of_machine_is_compatible("fsl,imx8dxl"))) {
+               board_type = BOARD_TYPE_DXL;
+       }  else if ((of_machine_is_compatible("fsl,imx95"))) {
+               board_type = BOARD_TYPE_IMX95;
+       }else {
+               pci_err(pdev, "Unkown board !\n");
+               return;
+       }
+       if (board_type == BOARD_TYPE_MP) {
+               pci_info(pdev, "%s board_type: i.MX8MP/i.MX8MM\n",__func__);
+       }
+       else if (board_type == BOARD_TYPE_DXL) {
+               pci_info(pdev, "%s board_type: i.MX8MP/i.MX8MM\n",__func__);
+       }
+       else if (board_type == BOARD_TYPE_IMX95) {
+               pci_info(pdev, "%s board_type: i.MX95\n",__func__);
+       }else {
+               pci_err(pdev, "Unkown board !\n");
+               return;
+       }
+
+       if (pci_enable_device_mem(pdev)) {
+               pci_err(pdev, "Can't enable device memory\n");
+               return;
+       }
+
+       //if (board_type == BOARD_TYPE_IMX95) {
+       //         return;
+       //}
+
+       phys_addr = pci_resource_start(pdev,0);
+       size = pci_resource_len(pdev, 0);
+       vaddr = ioremap(phys_addr, size);
+       if (!vaddr) {
+               pci_err(pdev, "ioremap failed !");
+               goto out;
+       }
+
+       if (board_type == BOARD_TYPE_MP) {
+               vaddr_hctrl = ioremap(PCIE_HCTRL_PHY, 1024);
+               iowrite32(PICE_HCTRL_TRGT_IVAL, (u32 *)(vaddr_hctrl +
+                                       PCIE_HCTRL_OFFSET));
+       }
+
+       iowrite16(ENABLE_INBOUND_MEM_ACCESS, (u32 *)(vaddr +
+                               PCIE_RHOM_DBI_BASE + PCIE_CMD_REG_OFFSET));
+       iowrite32(SET_BAR_MASK_VAL, (u32 *)(vaddr +  PCIE_RHOM_DBI_BASE +
+                               PCIE_BAR_MASK_REG_0));
+       if (board_type == BOARD_TYPE_MP) {
+               iowrite32(SET_BAR_MASK_MP,(u32 *)(vaddr +  PCIE_RHOM_DBI_BASE +
+                               PCIE_BAR_MASK_REG_1) );
+               iowrite32(PICE_HCTRL_TRGT_FVAL, (u32*)(vaddr_hctrl +
+                                       PCIE_HCTRL_OFFSET));
+               iounmap(vaddr_hctrl);
+       }
+
+       iounmap(vaddr);
+out:
+       pci_disable_device(pdev);
+}
+DECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_FREESCALE,
+               PCI_DEVICE_ID_LA9310_DISABLE_CIP, quirk_la9310_config_mem);
+DECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_FREESCALE,
+               PCI_DEVICE_ID_LA9310, quirk_la9310_config_mem);
+
 static void quirk_no_bus_reset(struct pci_dev *dev)
 {
 	dev->dev_flags |= PCI_DEV_FLAGS_NO_BUS_RESET;
-- 
2.34.1

