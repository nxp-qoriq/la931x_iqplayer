# SPDX-License-Identifier: (BSD-3-Clause OR GPL-2.0)
# Copyright 2022 - 2025  NXP



/*
  version history:
  1. 2021.08.10 V1.2    first release.
*/


/************************************************************************************
This filter implements the following algorithm
output[0][0] = H[0][0]*input[0] +  H[0][1]*input[1] + ... + H[0][15]*input[15].
output[0][1] = H[1][0]*input[0] +  H[1][1]*input[1] + ... + H[1][15]*input[15].
output[0][2] = H[2][0]*input[0] +  H[2][1]*input[1] + ... + H[2][15]*input[15].
output[0][3] = H[3][0]*input[0] +  H[3][1]*input[1] + ... + H[3][15]*input[15].
output[1][0] = H[0][0]*input[1] +  H[0][1]*input[2] + ... + H[0][15]*input[16].
output[1][1] = H[1][0]*input[1] +  H[1][1]*input[2] + ... + H[1][15]*input[16].
output[1][2] = H[2][0]*input[1] +  H[2][1]*input[2] + ... + H[2][15]*input[16].
output[1][3] = H[3][0]*input[1] +  H[3][1]*input[2] + ... + H[3][15]*input[16].
...

C model:

#define NUM_INPUT_SAMPLES       2048
#define NUM_TAP                  16
#define NUM_HISTORY_SAMPLES     8
#define NUM_ADVANCED_SAMPLES    7
#define NUM_INTERP               4

//history samples plus 2K complex intput plus advanced samples 
short input[NUM_HISTORY_SAMPLES + NUM_INPUT_SAMPLES + NUM_ADVANCED_SAMPLES][2] = { 0 };
short H[NUM_INTERP][NUM_TAP];               //4*16 taps filter
short output[NUM_INPUT_SAMPLES][NUM_INTERP][2]; //8K complex output

void main()
{
    for (int i = 0; i < NUM_INPUT_SAMPLES; i++)
    {
        for (int j = 0; j < NUM_INTERP; j++)
        {
             short sum0 = 0, sum1 = 0;
             for (int k = 0; k < NUM_TAP; k++)
             {
                 sum0 += input[i+k][0] * H[j][k];
                 sum1 += input[i+k][1] * H[j][k];
             }
             output[i][j][0] = sum0;
             output[i][j][1] = sum1;
        }
    }

    //update history samples
    for (int i = 0; i < NUM_HISTORY_SAMPLES; i++)
    {
        input[i][0] = input[i + NUM_INPUT_SAMPLES][0];
        input[i][1] = input[i + NUM_INPUT_SAMPLES][1];
    }
}

*************************************************************************************
history_buffer: only the last 15 samples are used.
filter_taps: interleaved 4 filters with 16 taps each, total 64 real data, each data duplicated twice, 
	total 128 data
interleaved filter taps format:
original filter format:  H[4][16]
interleaved filter format stored in DMEM (H[0][0] is the starting element at lowest address, H[3][15] at highest address):
	H[0][0],H[0][0],H[1][0],H[1][0],H[2][0],H[2][0],H[3][0],H[3][0],
	H[0][1],H[0][1],H[1][1],H[1][1],H[2][1],H[2][1],H[3][1],H[3][1],
	...
	H[0][15],H[0][15],H[1][15],H[1][15],H[2][15],H[2][15],H[3][15],H[3][15]
	
implementation details:
1. 128 filter taps stored in R4-R7, circular, repeatedly load into S0, incrementing 8 taps each time, each 8 taps replicated to whole S0
2. 8 history smaples loaded into R0L, 24 input samples loaded into R0H. R0 loaded into S1 with each sample repeating 4 times
   R0 right shifted 1 sample after each load. For each 16x4 samples output 31 samples history+input are needed. 
   For each 16x4 samples output the starting input sample pointer advances 16 samples, to load a full line, the pointer
   advances 1 line, after that the pointer moves back 16 samples to point to the starting input sample for next 16x4 samples output
3. cycle count measured in simulator is 2077 cycles
*/

#ifdef __VSPA3__

#define NUM_TAP                 		16
#define NUM_HISTORY_SAMPLES     		15 //8
//#define NUM_ADVANCED_SAMPLES    		0 //7
#define NUM_INTERP              		4
#define NUM_BYTE_EACH_SAMPLE    		4
#define OFFSET1							16*NUM_BYTE_EACH_SAMPLE

    .global _X4_interp_tap64_filter
    .type _X4_interp_tap64_filter, @function
_X4_interp_tap64_filter:
	clr.VRA;
	ld.laddr [a3]+1;	add a2, 128-NUM_HISTORY_SAMPLES*NUM_BYTE_EACH_SAMPLE;   //a2 point to first sample of history data
	ld.laddr [a3]+1;	add a1, (32-NUM_HISTORY_SAMPLES)*NUM_BYTE_EACH_SAMPLE;  //a1 point to 24th samples
	ld.laddr [a3]+1;														set.creg 23, 3;  //order_g = 2^3 = 0;  for S0group2nr to duplicate each group of 8 filter taps.
	ld.laddr [a3]+1;	ld.normal R4;
	ld [a2];			ld.normal R5;										set.VRAincr	rS0, NUM_INTERP*4; 
	ld [a1]-OFFSET1;	ld.normal R6;										set.creg 24, 1;  //order_i = 2^1 = 2;  for S1interp2nc to repeat each sample 4 times.
						ld.normal R7;										set.VRArange1 rS0, 4*64, 8*64-NUM_INTERP*4;
						ld.h2l R0;											set.prec single,half_fixed,half_fixed,F24,half_fixed; 
						ld.l2h R0;  										set.VRAptr rS0,4*64;	set.rot R0r2;	//R0 holds 8 history + 24 input samples
											rd S0;rd S1;rd S2;	ror;		set.smode S0group2nr,S1interp2nc,S2zeros;	set.VRAptr rst,2;
											rd S0;rd S1;	ror;			set.VRAptr rV, 2*64;
											rd S0;rd S1;	ror;	rmad;	set.VRArange1 rSt, 2, 3;
											rd S0;rd S1;	ror;	rmac;	set.VRAincr rSt, 1;
											rd S0;rd S1;	ror;	rmac;	sr g0,g0,4;
											rd S0;rd S1;	ror;	rmac;	sub g0,1;
											rd S0;rd S1;	ror;	rmac;	set.loop g0, NUM_TAP;
											rd S0;rd S1;	ror;	rmac;	set.creg 19, 1;  //write 2 lines
											rd S0;rd S1;	ror;	rmac;	loop_begin;	
	ld.laddr [a1]+1;						rd S0;rd S1;	ror;	rmac;
	ld [a1]-OFFSET1;						rd S0;rd S1;	ror;	rmac;
											rd S0;rd S1;	ror;	rmac;
						ld.h2l  R1;			rd S0;rd S1;	ror;	rmac;   //load for next round from its history to R1L
						ld.l2h  R1;			rd S0;rd S1;	ror;	rmac;   //load the following samples to fill the whole R1
						mv R0, R1;			rd S0;rd S1;	ror;	rmac;	//move R1 to R0 which will be used for next round immediately
											rd S0;rd S1;			rmac;
											rd S0;rd S1;	ror;	rmac;
											rd S0;rd S1;	ror;	rmac;	
											rd S0;rd S1;	ror;	rmad;
											rd S0;rd S1;	ror;	rmac;
											rd S0;rd S1;	ror;	rmac;	
											rd S0;rd S1;	ror;	rmac;	wr.straight;	
											rd S0;rd S1;	ror;	rmac;				st.laddr [a0]+1;	
											rd S0;rd S1;	ror;	rmac;				st.laddr [a0]+1;	loop_end;
											rd S0;rd S1;	ror;	rmac;	
											rd S0;rd S1;	ror;	rmac;
											rd S0;rd S1;	ror;	rmac;
											rd S0;rd S1;	ror;	rmac;
											rd S0;rd S1;	ror;	rmac;
											rd S0;rd S1;	ror;	rmac;
											rd S0;rd S1;	ror;	rmac;
	ld [a1];								rd S0;rd S1;			rmac;
																	rmac;									//load last line of input
																	rmac;
						ld.normal R2;
																						st [a2];             //store the last line of input to history
																						set.VRAptr rst, 2;
						rts;												wr.straight;
																						st.laddr [a0]+1;
						set.creg 19, 0;													st.laddr [a0]+1;
						

_X4_interp_tap64_filter_end:
F_X4_interp_tap64_filter_end:

#endif



#ifdef __VSPA2__

#define NUM_TAP                 		16
#define NUM_HISTORY_SAMPLES     		15 //8
//#define NUM_ADVANCED_SAMPLES    		0 //7
#define NUM_INTERP              		4
#define NUM_BYTE_EACH_SAMPLE    		4
#define NUM_WORD_EACH_SAMPLE    		2
//#define OFFSET1							16*NUM_BYTE_EACH_SAMPLE
#define OFFSET1							16*NUM_WORD_EACH_SAMPLE

    .global _X4_interp_tap64_filter
    .type _X4_interp_tap64_filter, @function
_X4_interp_tap64_filter:
	add a2, 64-NUM_HISTORY_SAMPLES*NUM_WORD_EACH_SAMPLE;   //a2 point to first sample of history data
	add a1, (32-NUM_HISTORY_SAMPLES)*NUM_WORD_EACH_SAMPLE;  //a1 point to 17th samples
	clr.VRA;
	ld.laddr [a3]+1;	
	ld.laddr [a3]+1;	
	ld.laddr [a3]+1;														set.creg 23, 3;  //order_g = 2^3 = 8;  for S0group2nr to duplicate each group of 8 filter taps.
	ld.laddr [a3]+1;	ld.normal R4;
	ld [a2]+0;			ld.normal R5;										set.VRAincr	rS0, NUM_INTERP*4; 	//8 floating coeffs
	ld [a1]-OFFSET1;	ld.normal R6;										set.creg 24, 1;  //order_i = 2^1 = 2;  for S1interp2nc to repeat each sample 4 times.
						ld.normal R7;										set.VRArange1 rS0, 4*64, 8*64-NUM_INTERP*4;
						ld.h2l R0;											set.prec single,half_fixed,half_fixed,single,half_fixed; 
						ld.l2h R0;  										set.VRAptr rS0,4*64;	set.rot R0r2;	//R0 holds 8 history + 24 input samples
											rd S0;rd S1;rd S2;	ror;		set.smode S0group2nr,S1interp2nc,S2zeros;	set.VRAptr rst,2;
											rd S0;rd S1;	ror;			set.VRAptr rV, 2*64;
											rd S0;rd S1;	ror;	rmad;	sr g0,g0,4;	//set.VRArange1 rSt, 2, 3;
											rd S0;rd S1;	ror;	rmac;	//sub g0,1;	//set.VRAincr rSt, 1;
											rd S0;rd S1;	ror;	rmac;	set.loop g0, NUM_TAP*2;
											rd S0;rd S1;	ror;	rmac;	
											rd S0;rd S1;	ror;	rmac;	
											rd S0;rd S1;	ror;	rmac;	loop_begin;	//set.creg 19, 1;  //write 2 lines
						mv R1,R0;			rd S0;rd S1;	ror;	rmac;	//	
											rd S0;rd S1;	ror;	rmac;
											rd S0;rd S1;	ror;	rmac;
											rd S0;rd S1;	ror;	rmac;
											rd S0;rd S1;	ror;	rmac;   //load for next round from its history to R1L
											rd S0;rd S1;	ror;	rmac;   //load the following samples to fill the whole R1
						mv R0, R1;			rd S0;rd S1;	ror;	rmac;	//move R1 to R0 which will be used for next round immediately
											rd S0;rd S1;			rmac;
											rd S0;rd S1;	ror;	rmac;
											rd S0;rd S1;	ror;	rmac;	
											rd S0;rd S1;	ror;	rmad;
											rd S0;rd S1;	ror;	rmac;
											rd S0;rd S1;	ror;	rmac;	
											rd S0;rd S1;	ror;	rmac;	wr.straight;	
											rd S0;rd S1;	ror;	rmac;				st.laddr [a0]+1;	
											rd S0;rd S1;	ror;	rmac;	//	//st.laddr [a0]+1;	
	ld.laddr [a1]+1;						rd S0;rd S1;	ror;	rmac;	
											rd S0;rd S1;	ror;	rmac;
	ld [a1]-OFFSET1;						rd S0;rd S1;	ror;	rmac;
						ld.h2l  R1;			rd S0;rd S1;	ror;	rmac;
						ld.normal R3;		rd S0;rd S1;	ror;	rmac;	//R3 is for history
						ld.l2h  R1;			rd S0;rd S1;	ror;	rmac;
						mv R0, R1;			rd S0;rd S1;	ror;	rmac;
											rd S0;rd S1;			rmac;
											rd S0;rd S1;	ror;	rmac;
											rd S0;rd S1;	ror;	rmac;
											rd S0;rd S1;	ror;	rmad;
											rd S0;rd S1;	ror;	rmac;
											rd S0;rd S1;	ror;	rmac;
											rd S0;rd S1;	ror;	rmac;	wr.straight;	
											rd S0;rd S1;	ror;	rmac;				st.laddr [a0]+1;	loop_end;
						rts;															set.VRAptr rst,3;
																						st [a2]+0;             //store the last line of input to history
						nop;

_X4_interp_tap64_filter_end:
F_X4_interp_tap64_filter_end:

#endif
