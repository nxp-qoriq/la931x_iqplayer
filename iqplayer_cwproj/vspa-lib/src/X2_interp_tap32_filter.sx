# SPDX-License-Identifier: (BSD-3-Clause OR GPL-2.0)
# Copyright 2022 - 2025  NXP



/*
  version history:
  1. 2021.12.02 V1.0    first release.
*/


/************************************************************************************
This filter implements the following algorithm
input x[n], n=0,1,...,(m*64-1).  number of input samples must be multiple of 64 samples, such as 2048, 2112 etc.
filter h[k], k=0,1,...,31
output y[n], n=0,1,...,(m*2*64-1).  number of output samples is double of number of input samples
y[n*2] = sigma(x[n-k]*h[k*2]),    k=0,1,...,15. n=0,1,...,(m*64-1)
y[n*2+1] = sigma(x[n-k]*h[k*2+1]),    k=0,1,...,15. n=0,1,...,(m*64-1)

example:
y[0] = x[-15]*h[30] + h[-14]*h[28] +...+ x[-1]*h[2] + x[0]*h[0]
y[1] = x[-15]*h[31] + h[-14]*h[29] +...+ x[-1]*h[3] + x[0]*h[1]
y[2] = x[-14]*h[30] + h[-13]*h[28] +...+ x[0]*h[2] + x[1]*h[0]
y[3] = x[-14]*h[31] + h[-13]*h[29] +...+ x[0]*h[3] + x[1]*h[1]
...


*************************************************************************************/

/* 
history_buffer: 1 line of DMEM
filter_taps: 32 single precision real data
filter taps format:
original filter format:  h[32]
required filter format stored in DMEM (h[30] is the starting element at lowest address, h[1] at highest address):
h[30],h[31],h[28],h[29]...h[0],h[1].
implementation details:
1. 32 filter taps stored in R4, repeatedly load into S0, incrementing 2 taps each time, each 2 taps replicated to whole S0
2. 15 history smaples loaded into R0L and R2L alternatively, 32 input samples loaded into R0H/R1L and R2H/R3L alternatively. R0/1 and R2/3 loaded into S1 with each sample repeating 2 times
   R0/1 or R2/3 right shifted 1 sample after each load. 
3. cycle count measured in simulator is 1040 cycles for 2048 samples input
*/

#include "vspa.h"

#ifdef __VSPA3__

#define NUM_2X_TAPS                 	32
#define NUM_TAP                 		(NUM_2X_TAPS/2)		//for each 1x, 2x 32taps equal to 1x16taps
#define NUM_HISTORY_SAMPLES     		(NUM_TAP-1)
#define NUM_ADVANCED_SAMPLES    		0
#define NUM_INTERP              		2
#define NUM_BYTE_EACH_SAMPLE    		4
#define OFFSET1							0 		//16*NUM_BYTE_EACH_SAMPLE


    .type _X2_interp_tap32_filter_inv_IQ, @function
    .global _X2_interp_tap32_filter
    .type _X2_interp_tap32_filter, @function

_X2_interp_tap32_filter:
	clr.VRA;			
	ld.laddr [a3]+1;	add a2, 128-NUM_HISTORY_SAMPLES*NUM_BYTE_EACH_SAMPLE;   //a2 point to first sample of history data
	ld [a2];			add a1, (32-NUM_HISTORY_SAMPLES)*NUM_BYTE_EACH_SAMPLE;  //a1 point to 24th samples
	ld [a1]-OFFSET1;														set.VRAincr	rS0, 4;
	ld.laddr [a1]+1;	ld.normal R4;										set.VRAptr rS0,4*64;	
	ld [a1]-OFFSET1;	ld.h2l R0;											set.prec single,half_fixed,half_fixed,F24,half_fixed; 
						ld.l2h_h2l R0; 										set.rot R0R1r2;	//R0 holds 8 history + 24 input samples
						ld.h2l  R2;			rd S0;rd S1;rd S2;	ror;		set.Smode S0i1i1r1r1, s1hlinecplx, S2zeros;
						ld.l2h_h2l  R2;		rd S0;rd S1;	ror;			sr g0,g0,6;
											rd S0;rd S1;	ror;	rmad;	sub g0,1;
											rd S0;rd S1;	ror;	rmac;	set.VRAptr rV,6*64
											rd S0;rd S1;	ror;	rmac;	set.VRAptr rSt,6;
											rd S0;rd S1;	ror;	rmac;	set.VRAincr rSt, 1;
											rd S0;rd S1;	ror;	rmac;	set.loop g0, NUM_TAP*2;
											rd S0;rd S1;	ror;	rmac;	set.creg 19, 1;  //write 2 lines
											rd S0;rd S1;	ror;	rmac;	loop_begin;	
											rd S0;rd S1;	ror;	rmac;
											rd S0;rd S1;	ror;	rmac;
											rd S0;rd S1;	ror;	rmac;
											rd S0;rd S1;	ror;	rmac;   
											rd S0;rd S1;	ror;	rmac;   
											rd S0;rd S1;	ror;	rmac;	
											rd S0;rd S1;			rmac;	set.VRAptr rS1,2*64;	set.VRAptr rS0,4*64;
											rd S0;rd S1;	ror;	rmac;	set.rot R2R3r2;
											rd S0;rd S1;	ror;	rmac;	
											rd S0;rd S1;	ror;	rmad;
											rd S0;rd S1;	ror;	rmac;
											rd S0;rd S1;	ror;	rmac;	
											rd S0;rd S1;	ror;	rmac;	wr.straight;set.VRAptr rst, 6;
											rd S0;rd S1;	ror;	rmac;				st.laddr [a0]+1;	
											rd S0;rd S1;	ror;	rmac;				st.laddr [a0]+1;
											rd S0;rd S1;	ror;	rmac;	
											rd S0;rd S1;	ror;	rmac;
											rd S0;rd S1;	ror;	rmac;
	ld.laddr [a1]+1;						rd S0;rd S1;	ror;	rmac;
	ld [a1]-OFFSET1;						rd S0;rd S1;	ror;	rmac;   
	ld.laddr [a1]+1;						rd S0;rd S1;	ror;	rmac;   
	ld [a1]-OFFSET1;	ld.h2l  R0;			rd S0;rd S1;	ror;	rmac;	
						ld.l2h_h2l  R0;		rd S0;rd S1;			rmac;	set.VRAptr rS1,0*64;	set.VRAptr rS0,4*64;
						ld.h2l  R2;			rd S0;rd S1;	ror;	rmac;	set.rot R0R1r2;
						ld.l2h_h2l  R2;		rd S0;rd S1;	ror;	rmac;	
											rd S0;rd S1;	ror;	rmad;
											rd S0;rd S1;	ror;	rmac;
											rd S0;rd S1;	ror;	rmac;	
											rd S0;rd S1;	ror;	rmac;	wr.straight;set.VRAptr rst, 6;
											rd S0;rd S1;	ror;	rmac;				st.laddr [a0]+1;	
											rd S0;rd S1;	ror;	rmac;				st.laddr [a0]+1;	loop_end;
											rd S0;rd S1;	ror;	rmac;	
											rd S0;rd S1;	ror;	rmac;
											rd S0;rd S1;	ror;	rmac;
											rd S0;rd S1;	ror;	rmac;
											rd S0;rd S1;	ror;	rmac;   
											rd S0;rd S1;	ror;	rmac;   
											rd S0;rd S1;	ror;	rmac;	
											rd S0;rd S1;			rmac;	set.VRAptr rS1,2*64;	set.VRAptr rS0,4*64;
											rd S0;rd S1;	ror;	rmac;	set.rot R2R3r2;
											rd S0;rd S1;	ror;	rmac;	
											rd S0;rd S1;	ror;	rmad;
											rd S0;rd S1;	ror;	rmac;
											rd S0;rd S1;	ror;	rmac;	
											rd S0;rd S1;	ror;	rmac;	wr.straight;set.VRAptr rst, 6;
											rd S0;rd S1;	ror;	rmac;				st.laddr [a0]+1;	
											rd S0;rd S1;	ror;	rmac;				st.laddr [a0]+1;
											rd S0;rd S1;	ror;	rmac;	
											rd S0;rd S1;	ror;	rmac;
											rd S0;rd S1;	ror;	rmac;
											rd S0;rd S1;	ror;	rmac;
											rd S0;rd S1;	ror;	rmac;
											rd S0;rd S1;	ror;	rmac;
											rd S0;rd S1;	ror;	rmac;
	ld [a1];								rd S0;rd S1;			rmac;
																	rmac;									//load last line of the 2K input
																	rmac;
						ld.normal R6;													set.VRAptr rst, 6;
																						st [a2];             //store the last line of input to history
																						set.VRAptr rst, 6;
																			wr.straight;set.Smode S0straight;
						rts;															st.laddr [a0]+1;
																						st.laddr [a0]+1;
						set.creg 19, 0;  //restore creg.19 to write 1 line

_X2_interp_tap32_filter_end:
F_X2_interp_tap32_filter_end:
    
#endif




#ifdef __VSPA2__

#define NUM_2X_TAPS                 	32
#define NUM_TAP                 		(NUM_2X_TAPS/2)		//for each 1x, 2x 32taps equal to 1x16taps
#define NUM_HISTORY_SAMPLES     		(NUM_TAP-1)
#define NUM_ADVANCED_SAMPLES    		0
#define NUM_INTERP              		2
#define NUM_UNIT_EACH_SAMPLE    		2
#define OFFSET1							(16*NUM_UNIT_EACH_SAMPLE)


    .type _X2_interp_tap32_filter, @function
    .global _X2_interp_tap32_filter
    .type _X2_interp_tap32_filter, @function

_X2_interp_tap32_filter:
	clr.VRA;		
	add a2, (32-NUM_HISTORY_SAMPLES)*NUM_UNIT_EACH_SAMPLE;   //a2 point to first sample of history data	
	add a1, (32-NUM_HISTORY_SAMPLES)*NUM_UNIT_EACH_SAMPLE;  //a1 point to 24th samples
	ld.laddr [a3]+1;	
	ld [a2]+0;			
	ld [a1]-OFFSET1;														set.VRAincr	rS0, 4;
	ld.laddr [a1]+1;	ld.normal R4;										set.VRAptr rS0,4*64;	
	ld [a1]-OFFSET1;	ld.h2l R0;											set.prec single,half_fixed,half_fixed,single,half_fixed; 
						ld.l2h_h2l R0; 										set.rot R0R1r2;	//R0 holds 8 history + 24 input samples
						ld.h2l  R2;			rd S0;rd S1;rd S2;	ror;		set.Smode S0i1i1r1r1, s1hlinecplx, S2zeros;
						ld.l2h_h2l  R2;		rd S0;rd S1;	ror;			sr g0,g0,5;
											rd S0;rd S1;	ror;	rmad;	//sub g0,1;
											rd S0;rd S1;	ror;	rmac;	set.VRAptr rV,6*64
											rd S0;rd S1;	ror;	rmac;	set.VRAptr rSt,6;
											rd S0;rd S1;	ror;	rmac;	set.loop g0, NUM_TAP*2;
											rd S0;rd S1;	ror;	rmac;	
											rd S0;rd S1;	ror;	rmac;	loop_begin;	
											rd S0;rd S1;	ror;	rmac;	
											rd S0;rd S1;	ror;	rmac;
											rd S0;rd S1;	ror;	rmac;
											rd S0;rd S1;	ror;	rmac;
											rd S0;rd S1;	ror;	rmac;   
											rd S0;rd S1;	ror;	rmac;   
											rd S0;rd S1;	ror;	rmac;	
											rd S0;rd S1;			rmac;	set.VRAptr rS1,2*64;	set.VRAptr rS0,4*64;
											rd S0;rd S1;	ror;	rmac;	set.rot R2R3r2;
											rd S0;rd S1;	ror;	rmac;	
											rd S0;rd S1;	ror;	rmad;
											rd S0;rd S1;	ror;	rmac;
											rd S0;rd S1;	ror;	rmac;	
											rd S0;rd S1;	ror;	rmac;	wr.straight;
											rd S0;rd S1;	ror;	rmac;				st.laddr [a0]+1;	
											rd S0;rd S1;	ror;	rmac;				
											rd S0;rd S1;	ror;	rmac;	
											rd S0;rd S1;	ror;	rmac;
	ld.laddr [a1]+1;						rd S0;rd S1;	ror;	rmac;
											rd S0;rd S1;	ror;	rmac;
	ld [a1]-OFFSET1;						rd S0;rd S1;	ror;	rmac;   
	ld.laddr [a1]+1;	ld.normal R7;		rd S0;rd S1;	ror;	rmac;   //R7 is for history
	ld [a1]-OFFSET1;	ld.h2l  R0;			rd S0;rd S1;	ror;	rmac;	
						ld.l2h_h2l  R0;		rd S0;rd S1;			rmac;	set.VRAptr rS1,0*64;	set.VRAptr rS0,4*64;
						ld.h2l  R2;			rd S0;rd S1;	ror;	rmac;	set.rot R0R1r2;
						ld.l2h_h2l  R2;		rd S0;rd S1;	ror;	rmac;	
											rd S0;rd S1;	ror;	rmad;
											rd S0;rd S1;	ror;	rmac;
											rd S0;rd S1;	ror;	rmac;	
											rd S0;rd S1;	ror;	rmac;	wr.straight;
											rd S0;rd S1;	ror;	rmac;				st.laddr [a0]+1;	loop_end;
						rts;															set.VRAptr rSt,7;												
																						st [a2]+0;             //store the last line of input to history
						nop;

_X2_interp_tap32_filter_end:
F_X2_interp_tap32_filter_end:

#endif

